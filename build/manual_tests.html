<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
    <title>Manual Tests</title>

    <script
      onload="LitJsSdk.litJsSdkLoadedInALIT()"
      src="/index.web.js"
    ></script>
    <script
      src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"
      type="application/javascript"
    ></script>
    <script>
      var chain = "polygon";

      //var authSig = JSON.parse("{\"sig\":\"0x18a173d68d2f78cc5c13da0dfe36eec2a293285bee6d42547b9577bf26cdc985660ed3dddc4e75d422366cac07e8a9fc77669b10373bef9c7b8e4280252dfddf1b\",\"derivedVia\":\"web3.eth.personal.sign\",\"signedMessage\":\"I am creating an account to use LITs at 2021-08-04T20:14:04.918Z\",\"address\":\"0xdbd360f30097fb6d938dcc8b7b62854b36160b45\"}")

      var testEncryptingFileAndZipWithMetadata = async ({
        accessControlConditions,
        evmContractConditions,
        solRpcConditions,
        unifiedAccessControlConditions,
        testName,
        authSig,
        chain,
      }) => {
        document.getElementById("status").innerText = `Testing ${testName}...`;
        var file = new File(["meow meow this is a test"], "testFilename.txt", {
          type: "text/plain",
        });

        const { zipBlob } = await LitJsSdk.encryptFileAndZipWithMetadata({
          file,
          accessControlConditions,
          evmContractConditions,
          solRpcConditions,
          unifiedAccessControlConditions,
          authSig,
          chain,
          litNodeClient,
          readme: "this is a test",
        });

        const { decryptedFile } = await LitJsSdk.decryptZipFileWithMetadata({
          authSig,
          litNodeClient,
          file: zipBlob,
        });

        var enc = new TextDecoder("utf-8");
        const decoded = enc.decode(decryptedFile);

        if (decoded && decoded === "meow meow this is a test") {
          document.getElementById(
            "status"
          ).innerText = `${testName} passed!  Decrypted string is "${decoded}"`;
          return true;
        } else {
          document.getElementById("status").innerText = `${testName} failed!`;
          return false;
        }
      };

      var randomPath = () =>
        "/" +
        Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15);
      var testProvisoningAndSigning = async ({
        accessControlConditions,
        testName,
        authSig,
      }) => {
        document.getElementById("status").innerText = `Testing ${testName}...`;
        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        if (!authSig) {
          authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });
        }

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        await litNodeClient.saveSigningCondition({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
        });

        let jwt = await litNodeClient.getSignedToken({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
        });
        console.log("jwt", jwt);

        // uncomment this to break the jwt, to test an invalid jwt
        // jwt = jwt.replace(/.$/, "3");

        const { verified, header, payload } = LitJsSdk.verifyJwt({ jwt });
        console.log("verified", verified);
        console.log("header", header);
        console.log("payload", payload);

        if (jwt && verified) {
          document.getElementById("status").innerText = `${testName}: Success`;
        } else {
          document.getElementById("status").innerText = `${testName}: Failure`;
        }
      };

      var NestedGrouping = async () => {
        // var accessControlConditions = [
        //   [
        //     {
        //       contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        //       standardContractType: "ERC721",
        //       chain: "xdai",
        //       method: "balanceOf",
        //       parameters: [":userAddress"],
        //       returnValueTest: {
        //         comparator: ">",
        //         value: "0",
        //       },
        //     },
        //     {
        //       operator: "and",
        //     },
        //     {
        //       contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        //       standardContractType: "POAP",
        //       chain: "xdai",
        //       method: "tokenURI",
        //       parameters: [],
        //       returnValueTest: {
        //         comparator: "contains",
        //         value: "test nested poap",
        //       },
        //     },
        //   ],
        //   {
        //     operator: "and",
        //   },
        //   {
        //     contractAddress: "",
        //     standardContractType: "",
        //     chain: "ethereum",
        //     method: "",
        //     parameters: [":userAddress"],
        //     returnValueTest: {
        //       comparator: "=",
        //       value: "0x50e2dac5e78B5905CB09495547452cEE64426db2",
        //     },
        //   },
        // ];

        var accessControlConditions = [
          [
            {
              contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
              standardContractType: "ERC721",
              chain: "xdai",
              method: "balanceOf",
              parameters: [":userAddress"],
              returnValueTest: {
                comparator: ">",
                value: "0",
              },
            },
            {
              operator: "and",
            },
            {
              contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
              standardContractType: "POAP",
              chain: "xdai",
              method: "tokenURI",
              parameters: [],
              returnValueTest: {
                comparator: "contains",
                value: "test poap",
              },
            },
          ],
        ];

        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "NestedGrouping",
        });
      };

      var ERC1155WithMinting = async () => {
        const chain = "ropsten";
        const { txHash, tokenId, tokenAddress, mintingAddress, authSig } =
          await LitJsSdk.mintLIT({ chain, quantity: 1 });

        var accessControlConditions = [
          {
            contractAddress: LitJsSdk.LIT_CHAINS[chain].contractAddress,
            standardContractType: "ERC1155",
            chain,
            method: "balanceOf",
            parameters: [":userAddress", tokenId.toString()],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC1155",
        });
      };

      var ERC1155 = async () => {
        var accessControlConditions = [
          {
            contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
            standardContractType: "ERC1155",
            chain,
            method: "balanceOf",
            parameters: [":userAddress", "8"],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC1155",
        });
      };

      var ERC1155WithHexTokenIdOnHarmony = async () => {
        var accessControlConditions = [
          {
            contractAddress: "0x08680d4b01b201ad3de4ab8d074597bc93e55391",
            standardContractType: "ERC1155",
            chain: "harmony",
            method: "balanceOf",
            parameters: [
              ":userAddress",
              "0xdbad33654bda2e12fac56805060289efd2f5f02d",
            ],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC1155",
        });
      };

      var ERC1155Batch = async () => {
        var accessControlConditions = [
          {
            contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
            standardContractType: "ERC1155",
            chain,
            method: "balanceOfBatch",
            parameters: [":userAddress,:userAddress,:userAddress", "8,9,34"],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC1155Batch",
        });
      };

      var ERC721NFT = async () => {
        var accessControlConditions = [
          {
            contractAddress: "0x319ba3aab86e04a37053e984bd411b2c63bf229e",
            standardContractType: "ERC721",
            chain,
            method: "ownerOf",
            parameters: ["5954"],
            returnValueTest: {
              comparator: "=",
              value: ":userAddress",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC721NFT",
        });
      };

      var ERC721Collection = async () => {
        const accessControlConditions = [
          {
            contractAddress: "0x319ba3aab86e04a37053e984bd411b2c63bf229e",
            standardContractType: "ERC721",
            chain,
            method: "balanceOf",
            parameters: [":userAddress"],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC721Collection",
        });
      };

      var SIWEDomainParam = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "SIWE",
            chain,
            method: "",
            parameters: [":domain"],
            returnValueTest: {
              comparator: "=",
              value: "localhost:3050",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "SIWEDomainParam",
        });
      };

      var SIWEResourceParam = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "SIWE",
            chain,
            method: "",
            parameters: [":resources"],
            returnValueTest: {
              comparator: "contains",
              value: "ipfs://someTestId",
            },
          },
        ];

        let authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
          resources: ["ipfs://someTestId", "ipfs://anotherTestId"],
        });

        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "SIWEResourceParam",
          authSig,
        });
      };

      var POAP = async () => {
        console.log(
          "!!! This test only works from address 0xdbd360F30097fB6d938dcc8B7b62854B36160B45"
        );
        const chain = "xdai";
        // var accessControlConditions = [
        //   // {
        //   //   contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        //   //   standardContractType: "ERC721",
        //   //   chain,
        //   //   method: "balanceOf",
        //   //   parameters: [":userAddress"],
        //   //   returnValueTest: {
        //   //     comparator: ">",
        //   //     value: "0",
        //   //   },
        //   // },
        //   {
        //     contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
        //     standardContractType: "POAP",
        //     chain,
        //     method: "tokenURI",
        //     parameters: [],
        //     returnValueTest: {
        //       comparator: "contains",
        //       value: "Burning Man 2021",
        //     },
        //   },
        // ];
        var accessControlConditions = [
          [
            {
              contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
              standardContractType: "POAP",
              chain: "xdai",
              method: "tokenURI",
              parameters: [],
              returnValueTest: {
                comparator: "contains",
                value: "Lit Protocol Test",
              },
            },
            {
              operator: "or",
            },
            {
              contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
              standardContractType: "POAP",
              chain: "ethereum",
              method: "tokenURI",
              parameters: [],
              returnValueTest: {
                comparator: "contains",
                value: "Lit Protocol Test",
              },
            },
          ],
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "POAP",
        });
      };

      var POAPEventId = async () => {
        console.log(
          "!!! This test only works from address 0xdbd360F30097fB6d938dcc8B7b62854B36160B45"
        );
        const chain = "xdai";

        var accessControlConditions = [
          {
            contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
            standardContractType: "POAP",
            chain: "xdai",
            method: "eventId",
            parameters: [],
            returnValueTest: {
              comparator: "=",
              value: "37582",
            },
          },
          {
            operator: "or",
          },
          {
            contractAddress: "0x22C1f6050E56d2876009903609a2cC3fEf83B415",
            standardContractType: "POAP",
            chain: "ethereum",
            method: "eventId",
            parameters: [],
            returnValueTest: {
              comparator: "=",
              value: "37582",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "POAPEventId",
        });
      };

      var ERC20 = async () => {
        const accessControlConditions = [
          {
            contractAddress: "0xc0ad7861fe8848002a3d9530999dd29f6b6cae75",
            standardContractType: "ERC20",
            chain,
            method: "balanceOf",
            parameters: [":userAddress"],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ERC20",
        });
      };

      var ETH = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETH",
        });
      };

      var ETHOnArbitrum = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "arbitrum",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnArbitrum",
        });
      };

      var ETHOnAvax = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "avalanche",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnAvax",
        });
      };

      var ETHOnFuji = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "fuji",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnFuji",
        });
      };

      var ETHOnCelo = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "celo",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnCelo",
        });
      };

      var ETHOnEth = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "ethereum",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnEth",
        });
      };

      var ETHOnXdai = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "xdai",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "EthOnXdai",
        });
      };

      var ETHOnAurora = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "aurora",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "EthOnAurora",
        });
      };

      var ETHOnEluvioEmptyWallet = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "eluvio",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnEluvioEmptyWallet",
        });
      };

      var ETHOnAlfajoresEmptyWallet = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain: "alfajores",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHOnAlfajoresEmptyWallet",
        });
      };

      var CASK = async () => {
        const accessControlConditions = [
          {
            contractAddress: "0x921ec72BEf414D75F0C6fFee37975BB3ae80d41C",
            standardContractType: "CASK",
            chain: "fuji",
            method: "getActiveSubscriptionCount",
            parameters: [
              ":userAddress",
              "0x50e2dac5e78B5905CB09495547452cEE64426db2",
              "100",
            ],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "CASK",
        });
      };

      var ETHPlusERC721 = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
          { operator: "and" },
          {
            contractAddress: "0x319ba3aab86e04a37053e984bd411b2c63bf229e",
            standardContractType: "ERC721",
            chain,
            method: "ownerOf",
            parameters: ["5954"],
            returnValueTest: {
              comparator: "=",
              value: ":userAddress",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETHPlusERC721",
        });
      };

      var ETHEmptyWallet = async () => {
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "0",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "ETH (Empty Wallet)",
        });
      };

      var RandomTestFromUser = async () => {
        const accessControlConditions = [
          {
            contractAddress: "0x588da869464f8c8eafa264f5b446e6c9bd4543ac",
            standardContractType: "ERC1155",
            chain: "ethereum",
            method: "balanceOf",
            parameters: [
              ":userAddress",
              "95268251546285662909660874610252721742451934934531784487819138932576410927105",
            ],
            returnValueTest: { comparator: ">=", value: "1" },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "RandomTestFromUser",
        });
      };

      var ProofOfHumanity = async () => {
        const accessControlConditions = [
          {
            contractAddress: "0xC5E9dDebb09Cd64DfaCab4011A0D5cEDaf7c9BDb",
            standardContractType: "ProofOfHumanity",
            chain: "ethereum",
            method: "isRegistered",
            parameters: [":userAddress"],
            returnValueTest: {
              comparator: "=",
              value: "true",
            },
          },
        ];
        await testProvisoningAndSigning({
          accessControlConditions,
          testName: "Proof of Humanity",
        });
      };

      var SignChainData = async () => {
        const testName = "SignChainData";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        document.getElementById("humanized").innerText = "";

        const aggregatorV3InterfaceABI = [
          {
            inputs: [],
            name: "decimals",
            outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
            stateMutability: "view",
            type: "function",
          },
          {
            inputs: [],
            name: "description",
            outputs: [{ internalType: "string", name: "", type: "string" }],
            stateMutability: "view",
            type: "function",
          },
          {
            inputs: [
              { internalType: "uint80", name: "_roundId", type: "uint80" },
            ],
            name: "getRoundData",
            outputs: [
              { internalType: "uint80", name: "roundId", type: "uint80" },
              { internalType: "int256", name: "answer", type: "int256" },
              { internalType: "uint256", name: "startedAt", type: "uint256" },
              { internalType: "uint256", name: "updatedAt", type: "uint256" },
              {
                internalType: "uint80",
                name: "answeredInRound",
                type: "uint80",
              },
            ],
            stateMutability: "view",
            type: "function",
          },
          {
            inputs: [],
            name: "latestRoundData",
            outputs: [
              { internalType: "uint80", name: "roundId", type: "uint80" },
              { internalType: "int256", name: "answer", type: "int256" },
              { internalType: "uint256", name: "startedAt", type: "uint256" },
              { internalType: "uint256", name: "updatedAt", type: "uint256" },
              {
                internalType: "uint80",
                name: "answeredInRound",
                type: "uint80",
              },
            ],
            stateMutability: "view",
            type: "function",
          },
          {
            inputs: [],
            name: "version",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
          },
        ];
        // this is the address for the chainlink eth/usd price oracle
        const addr = "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419";

        const callData = LitJsSdk.encodeCallData({
          abi: aggregatorV3InterfaceABI,
          functionName: "latestRoundData",
          functionParams: [],
        });

        const callRequests = [{ to: addr, data: callData }];
        console.log("callRequests", callRequests);

        const chain = "ethereum";

        const jwt = await litNodeClient.getSignedChainDataToken({
          callRequests,
          chain,
        });

        console.log("jwt", jwt);

        const { verified, header, payload, signature } = LitJsSdk.verifyJwt({
          jwt,
        });

        console.log("jwt payload: ", payload);

        // const decoded = iface.decodeFunctionResult(
        //   "latestRoundData",
        //   payload.callResponses[0]
        // );
        const decoded = LitJsSdk.decodeCallResult({
          abi: aggregatorV3InterfaceABI,
          functionName: "latestRoundData",
          data: payload.callResponses[0],
        });

        console.log("decoded", decoded);
        const answer = decoded.answer
          .div(ethers.BigNumber.from("10").pow(ethers.BigNumber.from("8")))
          .toString();
        console.log("answer: ", answer);

        if (jwt && verified) {
          document.getElementById(
            "status"
          ).innerText = `${testName}: Success - ETH Price is $${answer}`;
        } else {
          document.getElementById("status").innerText = `${testName}: Failure`;
        }
      };

      var SendBadRequestToNodes = async () => {
        const testName = "SendBadRequestToNodes";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        document.getElementById("humanized").innerText = "";

        const chain = "ethereum";

        var accessControlConditions = [
          {
            contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
            standardContractType: "ERC1155",
            chain,
            method: "balanceOf",
            parameters: [":userAddress", "8"],
            returnValueTest: {
              comparator: ">",
              value: "0",
            },
          },
        ];

        var authSig = await LitJsSdk.checkAndSignAuthMessage({ chain });

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        try {
          await litNodeClient.saveSigningCondition({
            accessControlConditions,
            //chain, // intentionally exclude this to cause an error parsing the JSON
            authSig,
            resourceId,
          });
        } catch (e) {
          console.log("error", e);
          document.getElementById(
            "status"
          ).innerText = `${testName}: Success (an error occured).  Check the Network tab of the inspector for more details.`;
          return;
        }
      };

      var EncryptDecrypt = async () => {
        const testName = "EncryptDecrypt";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        const retrievedSymmKey = await litNodeClient.getEncryptionKey({
          accessControlConditions,
          toDecrypt: LitJsSdk.uint8arrayToString(
            encryptedSymmetricKey,
            "base16"
          ),
          chain,
          authSig,
        });

        const decryptedFiles = await LitJsSdk.decryptZip(
          encryptedZip,
          retrievedSymmKey
        );
        const decryptedString = await decryptedFiles["string.txt"].async(
          "text"
        );
        console.log("decrypted string", decryptedString);

        document.getElementById(
          "status"
        ).innerText = `${testName}: Success.  Decrypted string is: ${decryptedString}`;
      };

      var EncryptDecryptWithAnUpdate = async () => {
        const testName = "EncryptDecryptWithAnUpdate";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
          permanant: false,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        let retrievedSymmKey;
        try {
          retrievedSymmKey = await litNodeClient.getEncryptionKey({
            accessControlConditions,
            toDecrypt: LitJsSdk.uint8arrayToString(
              encryptedSymmetricKey,
              "base16"
            ),
            chain,
            authSig,
          });
        } catch (e) {
          console.log("error getting symmetric key - this is expected", e);
          console.log("trying to update the condition");
          const newAccessControlConditions = [
            {
              contractAddress: "",
              standardContractType: "",
              chain,
              method: "eth_getBalance",
              parameters: [":userAddress", "latest"],
              returnValueTest: {
                comparator: ">=",
                value: "10000000000000",
              },
            },
          ];

          const newEncryptedSymmetricKey =
            await litNodeClient.saveEncryptionKey({
              accessControlConditions: newAccessControlConditions,
              encryptedSymmetricKey,
              authSig,
              chain,
              permanant: false,
            });
          console.log("updated the condition");

          retrievedSymmKey = await litNodeClient.getEncryptionKey({
            accessControlConditions: newAccessControlConditions,
            toDecrypt: LitJsSdk.uint8arrayToString(
              encryptedSymmetricKey,
              "base16"
            ),
            chain,
            authSig,
          });
        }

        const decryptedFiles = await LitJsSdk.decryptZip(
          encryptedZip,
          retrievedSymmKey
        );
        const decryptedString = await decryptedFiles["string.txt"].async(
          "text"
        );
        console.log("decrypted string", decryptedString);

        document.getElementById(
          "status"
        ).innerText = `${testName}: Success.  Decrypted string is: ${decryptedString}`;
      };

      var EncryptDecryptWithAnUnauthorizedUpdate = async () => {
        const testName = "EncryptDecryptWithAnUnauthorizedUpdate";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
          permanant: false,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        try {
          console.log(
            "trying to update the condition with an unauthorized address"
          );
          const newAccessControlConditions = [
            {
              contractAddress: "",
              standardContractType: "",
              chain,
              method: "eth_getBalance",
              parameters: [":userAddress", "latest"],
              returnValueTest: {
                comparator: ">=",
                value: "10000000000000",
              },
            },
          ];

          let unauthorizedAuthSig = {
            sig: "0x2229236873d413f301c1afb7650959dee9f9a984c7421c9a44e41009940a5e410925d03374ddaf51590c7899253f30d589f1d7fec694f15829c8157c24f999f81c",
            derivedVia: "web3.eth.personal.sign",
            signedMessage:
              "I am creating an account to use Lit Protocol at 2022-01-27T02:07:14.289Z",
            address: "0xb962537314b11c6bcd6d9ff63feb048a9e91e7ae",
          };

          const newEncryptedSymmetricKey =
            await litNodeClient.saveEncryptionKey({
              accessControlConditions: newAccessControlConditions,
              encryptedSymmetricKey,
              authSig: unauthorizedAuthSig,
              chain,
              permanant: false,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error getting symmetric key - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };

      var EncryptDecryptPermanantCondition = async () => {
        const testName = "EncryptDecryptPermanantCondition";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
          permanant: true,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        try {
          console.log("trying to update the permanant condition");
          const newAccessControlConditions = [
            {
              contractAddress: "",
              standardContractType: "",
              chain,
              method: "eth_getBalance",
              parameters: [":userAddress", "latest"],
              returnValueTest: {
                comparator: ">=",
                value: "10000000000000",
              },
            },
          ];

          const newEncryptedSymmetricKey =
            await litNodeClient.saveEncryptionKey({
              accessControlConditions: newAccessControlConditions,
              encryptedSymmetricKey,
              authSig,
              chain,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error getting symmetric key - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };

      var EncryptDecryptPermanentCondition = async () => {
        const testName = "EncryptDecryptPermanentCondition";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
          permanent: true,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        try {
          console.log("trying to update the permanent condition");
          const newAccessControlConditions = [
            {
              contractAddress: "",
              standardContractType: "",
              chain,
              method: "eth_getBalance",
              parameters: [":userAddress", "latest"],
              returnValueTest: {
                comparator: ">=",
                value: "10000000000000",
              },
            },
          ];

          const newEncryptedSymmetricKey =
            await litNodeClient.saveEncryptionKey({
              accessControlConditions: newAccessControlConditions,
              encryptedSymmetricKey,
              authSig,
              chain,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error getting symmetric key - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };

      var EncryptDecryptAGroup = async () => {
        const testName = "EncryptDecryptAGroup";
        document.getElementById("status").innerText = `Testing ${testName}...`;

        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          // holds some eth
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
          { operator: "and" },
          [
            // erc 1155 possession
            {
              contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
              standardContractType: "ERC1155",
              chain,
              method: "balanceOf",
              parameters: [":userAddress", "8"],
              returnValueTest: {
                comparator: ">",
                value: "0",
              },
            },
            { operator: "or" },
            // erc721 posession
            {
              contractAddress: "0x319ba3aab86e04a37053e984bd411b2c63bf229e",
              standardContractType: "ERC721",
              chain,
              method: "ownerOf",
              parameters: ["5954"],
              returnValueTest: {
                comparator: "=",
                value: ":userAddress",
              },
            },
          ],
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        const { encryptedZip, symmetricKey } =
          await LitJsSdk.zipAndEncryptString("this is a secret message");

        const encryptedSymmetricKey = await litNodeClient.saveEncryptionKey({
          accessControlConditions,
          symmetricKey,
          authSig,
          chain,
        });

        console.log("encrypted symmetric key", encryptedSymmetricKey);

        const retrievedSymmKey = await litNodeClient.getEncryptionKey({
          accessControlConditions,
          toDecrypt: LitJsSdk.uint8arrayToString(
            encryptedSymmetricKey,
            "base16"
          ),
          chain,
          authSig,
        });

        const decryptedFiles = await LitJsSdk.decryptZip(
          encryptedZip,
          retrievedSymmKey
        );
        const decryptedString = await decryptedFiles["string.txt"].async(
          "text"
        );
        console.log("decrypted string", decryptedString);

        document.getElementById(
          "status"
        ).innerText = `${testName}: Success.  Decrypted string is: ${decryptedString}`;
      };

      var EthSignWithAnUpdate = async () => {
        const testName = "EthSignWithAnUpdate";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        await litNodeClient.saveSigningCondition({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
          permanant: false,
        });

        // uncomment this to break the jwt, to test an invalid jwt
        // jwt = jwt.replace(/.$/, "3");

        const newAccessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        let jwt;
        try {
          jwt = await litNodeClient.getSignedToken({
            accessControlConditions,
            chain,
            authSig,
            resourceId,
            permanant: false,
          });
          console.log("jwt", jwt);
        } catch (e) {
          console.log("error getting symmetric key - this is expected", e);
          console.log("trying to update the condition");

          const saved = await litNodeClient.saveSigningCondition({
            accessControlConditions: newAccessControlConditions,
            chain,
            authSig,
            resourceId,
          });
          console.log("updated the condition");
        }

        jwt = await litNodeClient.getSignedToken({
          accessControlConditions: newAccessControlConditions,
          chain,
          authSig,
          resourceId,
        });

        const { verified, header, payload } = LitJsSdk.verifyJwt({ jwt });
        console.log("verified", verified);
        console.log("header", header);
        console.log("payload", payload);

        if (jwt && verified) {
          document.getElementById("status").innerText = `${testName}: Success`;
        } else {
          document.getElementById("status").innerText = `${testName}: Failure`;
        }
      };

      var EthSignWithAnUnauthorizedUpdate = async () => {
        const testName = "EthSignWithAnUnauthorizedUpdate";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        await litNodeClient.saveSigningCondition({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
          permanant: false,
        });

        // uncomment this to break the jwt, to test an invalid jwt
        // jwt = jwt.replace(/.$/, "3");

        const newAccessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        let jwt;
        try {
          let unauthorizedAuthSig = {
            sig: "0x2229236873d413f301c1afb7650959dee9f9a984c7421c9a44e41009940a5e410925d03374ddaf51590c7899253f30d589f1d7fec694f15829c8157c24f999f81c",
            derivedVia: "web3.eth.personal.sign",
            signedMessage:
              "I am creating an account to use Lit Protocol at 2022-01-27T02:07:14.289Z",
            address: "0xb962537314b11c6bcd6d9ff63feb048a9e91e7ae",
          };

          console.log("trying to update the condition");

          const newEncryptedSymmetricKey =
            await litNodeClient.saveSigningCondition({
              accessControlConditions: newAccessControlConditions,
              chain,
              authSig: unauthorizedAuthSig,
              resourceId,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error updating the condition - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };


  ///  ECDSA Test function
  var EcdsaSignMessage = async () => {
    const testName = "EcdsaSignMessage";
    document.getElementById("status").innerText = `Testing ${testName}...`;
    try {
      console.log("start signing message with ECDSA");
      const nodeResponse = await litNodeClient.signWithEcdsa({
        message: "LitProtocol rocks!",
        chain,
      });

      console.log("signed message with ECDSA");
      const vals = JSON.stringify(nodeResponse);
      document.getElementById(
        "status"
      ).innerText = `${testName}: Success. Response:  ${vals}`;
    } catch (e) {
      console.log("error signing with ECDSA", e);
      document.getElementById(
        "status"
      ).innerText = `${testName}: Failure.  `;
      return;
    }
  };

  var ecdsa_validate_ERC721 = async () => {

    const chain = "ethereum";

    var accessControlConditions = [
      {
        contractAddress: "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85",
        standardContractType: "ERC721",
        chain,
        method: "balanceOf",
        parameters: [":userAddress"],
        returnValueTest: {
          comparator: ">",
          value: "0",
        },
      },
    ];

    const testName = "ecdsa_validate_condition";


    document.getElementById("status").innerText = `Testing ${testName}...`;
    try {
      console.log("validating condition and ecdsa signing ");

      var auth_sig = await LitJsSdk.checkAndSignAuthMessage({ chain });

      const nodeResponse = await litNodeClient.validate_and_sign_ecdsa({
        accessControlConditions,
        chain,
        auth_sig,
      });
      //          let jwt = await litNodeClient.getSignedToken({
      console.log("validated & signed message with ECDSA");
      const vals = JSON.stringify(nodeResponse);
      document.getElementById(
        "status"
      ).innerText = `${testName}: Success. Response:  ${vals}`;
    } catch (e) {
      console.log("error validating & signing with ECDSA", e);
      document.getElementById(
        "status"
      ).innerText = `${testName}: Failure.  `;
      return;
    }




  };




      var EthSignPermanantCondition = async () => {
        const testName = "EthSignPermanantCondition";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        await litNodeClient.saveSigningCondition({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
          permanant: true,
        });

        // uncomment this to break the jwt, to test an invalid jwt
        // jwt = jwt.replace(/.$/, "3");

        const newAccessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        let jwt;
        try {
          console.log("trying to update the permanant condition");

          const newEncryptedSymmetricKey =
            await litNodeClient.saveSigningCondition({
              accessControlConditions: newAccessControlConditions,
              chain,
              authSig,
              resourceId,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error updating the condition - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };

      var EthSignPermanentCondition = async () => {
        const testName = "EthSignPermanentCondition";
        document.getElementById("status").innerText = `Testing ${testName}...`;
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "100000000000000000000000", // 100000 eth (or matic, really)
            },
          },
        ];

        document.getElementById(
          "humanized"
        ).innerText = `Humanized: ${await LitJsSdk.humanizeAccessControlConditions(
          { accessControlConditions }
        )}`;

        let resourceId = {
          baseUrl: "my-dynamic-content-server.com",
          path: randomPath(),
          orgId: "",
          role: "",
          extraData: "",
        };

        await litNodeClient.saveSigningCondition({
          accessControlConditions,
          chain,
          authSig,
          resourceId,
          permanent: true,
        });

        // uncomment this to break the jwt, to test an invalid jwt
        // jwt = jwt.replace(/.$/, "3");

        const newAccessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        let jwt;
        try {
          console.log("trying to update the permanent condition");

          const newEncryptedSymmetricKey =
            await litNodeClient.saveSigningCondition({
              accessControlConditions: newAccessControlConditions,
              chain,
              authSig,
              resourceId,
            });
          console.log("updated the condition");
        } catch (e) {
          console.log("error updating the condition - this is expected", e);
          if (e.errorCode === "storage_error") {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Success.  We were unable to update.`;
          } else {
            document.getElementById(
              "status"
            ).innerText = `${testName}: Failure.  When we tried to update with an unauthorized acct, we got an error that isn't a storage error`;
          }
          return;
        }

        document.getElementById(
          "status"
        ).innerText = `${testName}: Failure.  We updated a condition we shouldn't been able to!  OMG FIX THIS`;
      };

      var EncryptFileAndZipWithMetadata = async () => {
        const testResults = {};
        const testName = "EncryptFileAndZipWithMetadata";
        const authSig = await LitJsSdk.checkAndSignAuthMessage({
          chain,
        });
        const accessControlConditions = [
          {
            contractAddress: "",
            standardContractType: "",
            chain,
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
        ];

        let res = await testEncryptingFileAndZipWithMetadata({
          accessControlConditions,
          testName,
          authSig,
          chain: "polygon",
        });
        testResults.accessControlConditions = res;

        var evmContractConditions = [
          {
            contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
            functionName: "balanceOf",
            functionParams: [":userAddress", "8"],
            functionAbi: {
              type: "function",
              stateMutability: "view",
              outputs: [
                {
                  type: "uint256",
                  name: "",
                  internalType: "uint256",
                },
              ],
              name: "balanceOf",
              inputs: [
                {
                  type: "address",
                  name: "account",
                  internalType: "address",
                },
                {
                  type: "uint256",
                  name: "id",
                  internalType: "uint256",
                },
              ],
            },
            chain,
            returnValueTest: {
              key: "",
              comparator: ">",
              value: "0",
            },
          },
        ];

        res = await testEncryptingFileAndZipWithMetadata({
          evmContractConditions,
          testName,
          authSig,
          chain: "polygon",
        });

        testResults.evmContractConditions = res;

        var solAuthSig = await LitJsSdk.checkAndSignAuthMessage({
          chain: "solana",
        });

        var solRpcConditions = [
          {
            method: "getBalance",
            params: [":userAddress"],
            chain: "solana",
            returnValueTest: {
              key: "",
              comparator: ">=",
              value: "100000000", // equals 0.1 SOL
            },
          },
        ];

        res = await testEncryptingFileAndZipWithMetadata({
          solRpcConditions,
          testName,
          authSig: solAuthSig,
          chain: "solana",
        });
        testResults.solRpcConditions = res;

        var unifiedAccessControlConditions = [
          {
            conditionType: "solRpc",
            method: "getBalance",
            params: [":userAddress"],
            chain: "solana",
            returnValueTest: {
              key: "",
              comparator: ">=",
              value: "100000000", // equals 0.1 SOL
            },
          },
          { operator: "or" },
          {
            conditionType: "evmBasic",
            contractAddress: "",
            standardContractType: "",
            chain: "ethereum",
            method: "eth_getBalance",
            parameters: [":userAddress", "latest"],
            returnValueTest: {
              comparator: ">=",
              value: "10000000000000",
            },
          },
          { operator: "or" },
          {
            conditionType: "evmContract",
            contractAddress: "0x7C7757a9675f06F3BE4618bB68732c4aB25D2e88",
            functionName: "balanceOf",
            functionParams: [":userAddress", "8"],
            functionAbi: {
              type: "function",
              stateMutability: "view",
              outputs: [
                {
                  type: "uint256",
                  name: "",
                  internalType: "uint256",
                },
              ],
              name: "balanceOf",
              inputs: [
                {
                  type: "address",
                  name: "account",
                  internalType: "address",
                },
                {
                  type: "uint256",
                  name: "id",
                  internalType: "uint256",
                },
              ],
            },
            chain: "polygon",
            returnValueTest: {
              key: "",
              comparator: ">",
              value: "0",
            },
          },
        ];

        res = await testEncryptingFileAndZipWithMetadata({
          unifiedAccessControlConditions,
          testName,
          authSig: {
            ethereum: authSig,
            solana: solAuthSig,
          },
        });
        testResults.unifiedAccessControlConditions = res;

        console.log("testResults", testResults);

        if (Object.values(testResults).every((res) => res === true)) {
          document.getElementById(
            "status"
          ).innerText = `${testName}: Success.  All tests passed.`;
        } else {
          document.getElementById(
            "status"
          ).innerText = `${testName}: Failure.  One or more tests failed.  Check the console for the testResults object to see which one.`;
        }
      };

      var logout = async () => {
        const testName = "Logout";
        document.getElementById("status").innerText = `Testing ${testName}...`;

        LitJsSdk.disconnectWeb3();

        document.getElementById(
          "status"
        ).innerText = `${testName}: Success - Logged out`;
      };

      document.addEventListener(
        "lit-ready",
        function (e) {
          console.log("LIT network is ready");
          document.getElementById("networkStatus").innerText =
            "Success!  Connected to Lit Protocol Network";
        },
        false
      );
    </script>
  </head>

  <body>
    <h1>Manual tests</h1>
    <br />
    <br />
    <div id="networkStatus">Connecting to Lit Protocol Network...</div>
    <br />
    <br />
    <button onclick="ETHEmptyWallet()">ETH (Empty Wallet)</button>
    <br />
    <br />
    <button onclick="ERC1155WithMinting()">ERC1155WithMinting</button>
    <br />
    <br />
    <button onclick="ERC1155()">ERC1155</button>
    <br />
    <br />
    <button onclick="ERC1155WithHexTokenIdOnHarmony()">
      ERC1155WithHexTokenIdOnHarmony
    </button>
    <br />
    <br />
    <button onclick="ERC1155Batch()">ERC1155Batch</button>
    <br />
    <br />
    <button onclick="ERC721NFT()">ERC721NFT</button>
    <br />
    <br />
    <button onclick="ERC721Collection()">ERC721Collection</button>
    <br />
    <br />
    <button onclick="SIWEDomainParam()">SIWEDomainParam</button>
    <br />
    <br />
    <button onclick="SIWEResourceParam()">SIWEResourceParam</button>
    <br />
    <br />
    <button onclick="POAP()">POAP</button>
    <br />
    <br />
    <button onclick="POAPEventId()">POAPEventId</button>
    <br />
    <br />
    <button onclick="ERC20()">ERC20</button>
    <br />
    <br />
    <button onclick="ProofOfHumanity()">Proof of humanity</button>
    <br />
    <br />
    <button onclick="ETH()">ETH</button>
    <br />
    <br />
    <button onclick="ETHOnArbitrum()">ETHOnArbitrum</button>
    <br />
    <br />
    <button onclick="ETHOnAvax()">ETHOnAvax</button>
    <br />
    <br />
    <button onclick="ETHOnFuji()">ETHOnFuji</button>
    <br />
    <br />
    <button onclick="ETHOnCelo()">ETHOnCelo</button>
    <br />
    <br />
    <button onclick="ETHOnEth()">ETHOnEth</button>
    <br />
    <br />
    <button onclick="ETHOnXdai()">ETHOnXdai</button>
    <br />
    <br />
    <button onclick="ETHOnAurora()">ETHOnAurora</button>
    <br />
    <br />
    <button onclick="ETHOnEluvioEmptyWallet()">ETHOnEluvioEmptyWallet</button>
    <br />
    <br />
    <button onclick="ETHOnAlfajoresEmptyWallet()">
      ETHOnAlfajoresEmptyWallet
    </button>
    <br />
    <br />
    <button onclick="CASK()">CASK</button>
    <br />
    <br />
    <button onclick="ETHPlusERC721()">
      ETH + ERC721 (boolean group signing)
    </button>
    <br />
    <br />
    <button onclick="SignChainData()">Sign Chain Data</button>
    <br />
    <br />
    <button onclick="SendBadRequestToNodes()">
      Send a bad request to the nodes
    </button>
    <br />
    <br />
    <button onclick="EncryptDecrypt()">Encrypt then Decrypt</button>
    <br />
    <br />
    <button onclick="EncryptDecryptWithAnUpdate()">
      Encrypt, set the conditions, update the conditions, then Decrypt
    </button>
    <br />
    <br />
    <button onclick="EncryptDecryptWithAnUnauthorizedUpdate()">
      Encrypt, set the conditions, then try to update the conditions with an
      unauthorized account
    </button>
    <br />
    <br />
    <button onclick="EncryptDecryptPermanantCondition()">
      Encrypt, set the conditions as permanant, then try to update the
      conditions
    </button>
    <br />
    <br />
    <button onclick="EncryptDecryptPermanentCondition()">
      Encrypt, set the conditions as permanent (but with the correct spelling),
      then try to update the conditions
    </button>
    <br />
    <br />
    <button onclick="EncryptDecryptAGroup()">
      Encrypt then Decrypt a boolean group of conditions
    </button>
    <br />
    <br />
    <button onclick="EthSignWithAnUpdate()">
      JWT request - Set the conditions, update the conditions, then get JWT
    </button>
    <br />
    <br />
    <button onclick="EthSignWithAnUnauthorizedUpdate()">
      JWT request - Set the conditions, then try to update the conditions with
      an unauthorized account
    </button>
    <br />
    <br />
    <button onclick="EthSignPermanantCondition()">
      JWT request - Set the conditions as permanant, then try to update the
      conditions
    </button>
    <br />
    <br />
    <button onclick="EthSignPermanentCondition()">
      JWT request - Set the conditions as permanent (but with the correct
      spelling), then try to update the conditions
    </button>
    <br />
    <br />


        <button onclick="EcdsaSignMessage()">
          Nodes sign the message "LitProtocol Rocks!" using ECDSA with default key.
        </button>
        <br />
        <br />
        <button onclick="ecdsa_validate_ERC721()">
          Cross chain validation of NFT (ERC721) /w ECDSA signature result.
        </button>
        <br />
        <br /><button onclick="EthSignPermanentCondition()">
          >>>>>>> Stashed changes
          JWT request - Set the conditions as permanent (but with the correct
          spelling), then try to update the conditions
        </button>
        <br />
        <br />


        
    <button onclick="NestedGrouping()">NestedGrouping</button>
    <br />
    <br />

    <button onclick="RandomTestFromUser()">RandomTestFromUser</button>
    <br />
    <br />

    <button onclick="EncryptFileAndZipWithMetadata()">
      EncryptFileAndZipWithMetadata
    </button>
    <br />
    <br />

    <button onclick="logout()">Logout</button>
    <br />
    <br />
    <h2 id="status"></h2>
    <br />
    <p id="humanized"></p>
  </body>
</html>
